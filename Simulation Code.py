# -*- coding: utf-8 -*-
"""Project_deep_learning_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RMT8PbBCkPucDP3An2EpVuusmoJjmpiq
"""

from google.colab import drive
drive.mount('/content/drive')

# File Handling and System
import os

# Image Processing
import cv2
import numpy as np

# Data Manipulation
import pandas as pd

# Visualization
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Deep Learning Libraries
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.optimizers import Adam

# Evaluation Metrics
from sklearn.metrics import classification_report, confusion_matrix
import itertools

# Define paths
train_benign_dir = "//content//drive//MyDrive//test//Benign"
train_malignant_dir = r"/content/drive/MyDrive/train/Malignant"
test_benign_dir = r"/content/drive/MyDrive/test/Benign"
test_malignant_dir = r"/content/drive/MyDrive/test/Malignant"

# Function to load images and labels
def load_images_and_labels(dir_path, label):
    images = []
    labels = []
    for filename in os.listdir(dir_path):
        img_path = os.path.join(dir_path, filename)
        img = cv2.imread(img_path)
        if img is not None: # Check if image was loaded correctly
            img = cv2.resize(img, (224, 224))
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            images.append(img)
            labels.append(label)
        else:
            print(f"Failed to load image: {img_path}") # Print message to identify problematic images
    return images, labels

# Load train and test images
train_benign_images, train_benign_labels = load_images_and_labels(train_benign_dir, 0)
train_malignant_images, train_malignant_labels = load_images_and_labels(train_malignant_dir, 1)
test_benign_images, test_benign_labels = load_images_and_labels(test_benign_dir, 0)
test_malignant_images, test_malignant_labels = load_images_and_labels(test_malignant_dir, 1)

# Combine train and test datasets
X_train = np.array(train_benign_images + train_malignant_images)
y_train = np.array(train_benign_labels + train_malignant_labels)
X_test = np.array(test_benign_images + test_malignant_images)
y_test = np.array(test_benign_labels + test_malignant_labels)



# EDA with Plotly
def plot_sample_images(images, labels, title):
    fig = make_subplots(rows=2, cols=5, subplot_titles=[f'Label: {label}' for label in labels[:10]])
    for i, img in enumerate(images[:10]):
        fig.add_trace(px.imshow(img).data[0], row=(i // 5) + 1, col=(i % 5) + 1)
    fig.update_layout(height=600, width=1000, title_text=title)
    fig.show()

plot_sample_images(X_train, y_train, "Sample Training Images")

# Image Data Augmentation
datagen = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True,
    zoom_range=0.2
)

# Model Building
base_model = ResNet50(include_top=False, input_shape=(224, 224, 3), weights='imagenet')

for layer in base_model.layers:
    layer.trainable = False
    
x = Flatten()(base_model.output)
x = Dense(128, activation='relu')(x)
x = Dense(1, activation='sigmoid')(x)
model = Model(inputs=base_model.input, outputs=x)


model.compile(optimizer=Adam(learning_rate=1e-4), loss='binary_crossentropy', metrics=['accuracy'])

# Model Training
history = model.fit(datagen.flow(X_train, y_train, batch_size=32), validation_data=(X_test, y_test), epochs=5)

# Model Evaluation
y_pred = (model.predict(X_test) > 0.5).astype("int32")

# Confusion Matrix and Classification Report
cm = confusion_matrix(y_test, y_pred)
cr = classification_report(y_test, y_pred, target_names=['Benign', 'Malignant'])

# Plot Confusion Matrix
def plot_confusion_matrix(cm, classes):
    plt.figure(figsize=(8, 6))
    plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
    plt.title('Confusion Matrix')
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)
    fmt = 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt), horizontalalignment="center", color="white" if cm[i, j] > thresh else "black")
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.show()

plot_confusion_matrix(cm, classes=['Benign', 'Malignant'])

# Plot Training History
def plot_training_history(history):
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=list(range(1, len(history.history['accuracy']) + 1)), y=history.history['accuracy'], mode='lines', name='Train Accuracy'))
    fig.add_trace(go.Scatter(x=list(range(1, len(history.history['val_accuracy']) + 1)), y=history.history['val_accuracy'], mode='lines', name='Validation Accuracy'))
    fig.add_trace(go.Scatter(x=list(range(1, len(history.history['loss']) + 1)), y=history.history['loss'], mode='lines', name='Train Loss'))
    fig.add_trace(go.Scatter(x=list(range(1, len(history.history['val_loss']) + 1)), y=history.history['val_loss'], mode='lines', name='Validation Loss'))
    fig.update_layout(title='Training History', xaxis_title='Epoch', yaxis_title='Value')
    fig.show()

plot_training_history(history)

